<!DOCTYPE html>
<html>

<head>
	<!-- Meta -->
	<meta charset="UTF-8"/>
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
	<meta name="generator" content="Jekyll">

	<title>Linux Command Line Text Processing</title>
  <meta name="description" content="Linux Command Line Text Processing">

	<!-- CSS & fonts -->
	<link rel="stylesheet" href="/css/main.css">


	<!-- RSS -->
	<link href="/atom.xml" type="application/atom+xml" rel="alternate" title="ATOM Feed" />

  <!-- Favicon -->
  <link rel="shortcut icon" type="image/png" href="img/cantik-icon.png">

 <!-- Tambahan include JQuery -->
	<script src="js/jquery.min.js"></script>
	<script src="js/hijricalendar-kuwaiti.js"></script>
	<script src="js/modulku.js"></script>

	<!-- Begin Jekyll SEO tag v2.2.0 -->
<title>Linux Command Line Text Processing | IkhwanElyas Page</title>
<meta property="og:title" content="Linux Command Line Text Processing" />
<meta name="author" content="Ikhwan Elyas" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Linux Command Line Text Processing" />
<meta property="og:description" content="Linux Command Line Text Processing" />
<link rel="canonical" href="http://0.0.0.0:4000//linux-command-line-text-processing" />
<meta property="og:url" content="http://0.0.0.0:4000//linux-command-line-text-processing" />
<meta property="og:site_name" content="IkhwanElyas Page" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-12-02T00:00:00+07:00" />
<script type="application/ld+json">
{"@context": "http://schema.org",
"@type": "BlogPosting",
"headline": "Linux Command Line Text Processing",
"author": {"@type": "Person",
"name": {"name":"Ikhwan Elyas","email":"elyas.uii14@gmail.com","url":"https://abuisa.github.io"}},
"datePublished": "2017-12-02T00:00:00+07:00",
"description": "Linux Command Line Text Processing",
"mainEntityOfPage": {"@type": "WebPage",
"@id": "http://0.0.0.0:4000//linux-command-line-text-processing"},
"url": "http://0.0.0.0:4000//linux-command-line-text-processing"}</script>
<!-- End Jekyll SEO tag -->


</head>


<body>
	<div id="wrap">
	  	
	  	<!-- Navigation -->
	  	<nav id="nav">
	<div id="nav-list">
		<a href="http://0.0.0.0:4000/">Home</a>

    <!-- Nav links -->
	  <!--
<a href="https://github.com/abuisa/web">Github</a> 
<a href="https://ikhwanelyas.blogspot.co.id/">Blog</a>

<a href="https://ikhwanelyas.blogspot.co.id/">Blog</a>
<a href="/home.md">Home</a>
-->
 

	<!-- Nav pages -->
	  
	    
	  
	    
	  
	    
	      <a href="/categories" title="All Post">All Post</a> 
	    
	  
	    
	  
	    
	      <a href="/linkcolection" title="Links">Links</a> 
	    
	  
	    
	  
	    
	      <a href="/me" title="About">About</a> 
	    
	  
	    
	      <a href="/penelitian" title="Penelitian">Penelitian</a> 
	    
	  
	    
	  
	    
	  
	    
	  
	    
	  
	    
	  
	    
	  
	    
	  
	    
	  
    

	</div>
  
  <!-- Nav footer -->
	
	  <footer>
	
	<span>version 1.0.0</span>

</footer>
	

</nav>

    
    <!-- Icon menu -->
	  <a id="nav-menu">
	  	<div id="menu"></div>
	  </a>

      <!-- Header -->
      
        <header id="header" class="parent justify-spaceBetween">
  <div class="inner w100 relative">
<!--
    <span class="f-left">  
      <a href="//">
        <h1>
          Ikhwan<span>Elyas</span> 
        </h1>
      </a>
    </span>
-->
    <span class="f-left">  
      <a href="http://0.0.0.0:4000/"> <!-- |site.baseurl : / | site.url : http://0.0.0.0:4000 -->
        <h1>
          Ikhwan<span>Elyas</span> 
        </h1>
      </a>
    </span>
    <span id="nav-links" class="absolute right bottom">
      <!-- Nav links -->
	    <!--
<a href="https://github.com/abuisa/web">Github</a> 
<a href="https://ikhwanelyas.blogspot.co.id/">Blog</a>

<a href="https://ikhwanelyas.blogspot.co.id/">Blog</a>
<a href="/home.md">Home</a>
-->
 

      <!-- Nav pages -->
	    
	      
	    
	      
	    
	      
	        <a href="/categories" title="All Post">All Post</a> 
	      
	    
	      
	    
	      
	        <a href="/linkcolection" title="Links">Links</a> 
	      
	    
	      
	    
	      
	        <a href="/me" title="About">About</a> 
	      
	    
	      
	        <a href="/penelitian" title="Penelitian">Penelitian</a> 
	      
	    
	      
	    
	      
	    
	      
	    
	      
	    
	      
	    
	      
	    
	      
	    
	      
	    
      
    </span>
  </div>
</header>
<button onclick="topFunction()" id="myBtn" title="Go to top">Top</button>



      

    <!-- Main content -->
	  <div id="container">
		  
		<main>

			<article id="post-page">
	<h2>Linux Command Line Text Processing</h2>		
	<time datetime="2017-12-02T00:00:00+07:00" class="by-line">02 Dec 2017 | Linux</time>
	<div class="content">

		<h1 id="text-processing"><a name="text-processing"></a>Text Processing</h1>

<ul>
  <li><a href="#sort">sort</a></li>
  <li><a href="#uniq">uniq</a></li>
  <li><a href="#comm">comm</a></li>
  <li><a href="#cmp">cmp</a></li>
  <li><a href="#diff">diff</a></li>
  <li><a href="#tr">tr</a></li>
  <li><a href="#sed">sed</a></li>
  <li><a href="#awk">awk</a></li>
  <li><a href="#perl">perl</a></li>
  <li><a href="#cut">cut</a></li>
  <li><a href="#paste">paste</a></li>
  <li><a href="#column">column</a></li>
  <li><a href="#pr">pr</a></li>
</ul>

<p>The rich set of text processing commands is comprehensive and time saving. Knowing even their existence is enough to avoid the need of writing yet another script (which takes time and effort plus debugging) â€“ a trap which many beginners fall into. An extensive list of text processing commands and examples can be found <a href="http://tldp.org/LDP/abs/html/textproc.html">here</a></p>

<p><br /></p>

<h3 id="sort"><a name="sort"></a>sort</h3>

<blockquote>
  <p>sort lines of text files</p>
</blockquote>

<p>As the name implies, this command is used to sort files. How about alphabetic sort and numeric sort? Possible. How about sorting a particular column? Possible. Prioritized multiple sorting order? Possible. Randomize? Unique? Just about any sorting need is catered by this powerful command</p>

<p><strong>Options</strong></p>

<ul>
  <li><code class="highlighter-rouge">-R</code> random sort</li>
  <li><code class="highlighter-rouge">-r</code> reverse the sort order</li>
  <li><code class="highlighter-rouge">-o</code> redirect sorted result to specified filename, very useful to sort a file inplace</li>
  <li><code class="highlighter-rouge">-n</code> sort numerically</li>
  <li><code class="highlighter-rouge">-V</code> version sort, aware of numbers within text</li>
  <li><code class="highlighter-rouge">-h</code> sort human readable numbers like 4K, 3M, etc</li>
  <li><code class="highlighter-rouge">-k</code> sort via key</li>
  <li><code class="highlighter-rouge">-u</code> sort uniquely</li>
  <li><code class="highlighter-rouge">-b</code> ignore leading white-spaces of a line while sorting</li>
  <li><code class="highlighter-rouge">-t</code> use SEP instead of non-blank to blank transition</li>
</ul>

<p><strong>Examples</strong></p>

<ul>
  <li><code class="highlighter-rouge">sort dir_list.txt</code> display sorted file on standard output</li>
  <li><code class="highlighter-rouge">sort -bn numbers.txt -o numbers.txt</code> sort numbers.txt numerically (ignoring leading white-spaces) and overwrite the file with sorted output</li>
  <li><code class="highlighter-rouge">sort -R crypto_keys.txt -o crypto_keys_random.txt</code> sort randomly and write to new file
    <ul>
      <li><code class="highlighter-rouge">shuf crypto_keys.txt -o crypto_keys_random.txt</code> can also be used</li>
    </ul>
  </li>
  <li><code class="highlighter-rouge">du -sh * | sort -h</code> sort file/directory sizes in current directory in human readable format</li>
</ul>

<p><br /></p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="gp">$ </span>cat ip.txt 
6.2  : 897 : bar
3.1  : 32  : foo
2.3  : 012 : bar
1.2  : 123 : xyz

<span class="gp">$ </span><span class="c"># -k3,3 means from 3rd column onwards to 3rd column</span>
<span class="gp">$ </span><span class="c"># for ex: to sort from 2nd column till end, use -k2</span>
<span class="gp">$ </span>sort -t: -k3,3 ip.txt 
2.3  : 012 : bar
6.2  : 897 : bar
3.1  : 32  : foo
1.2  : 123 : xyz

<span class="gp">$ </span><span class="c"># -n option for numeric sort, check out what happens when -n is not used</span>
<span class="gp">$ </span>sort -t: -k2,2n ip.txt 
2.3  : 012 : bar
3.1  : 32  : foo
1.2  : 123 : xyz
6.2  : 897 : bar

<span class="gp">$ </span><span class="c"># more than one rule can be specified to resolve same values</span>
<span class="gp">$ </span>sort -t: -k3,3 -k1,1rn ip.txt 
6.2  : 897 : bar
2.3  : 012 : bar
3.1  : 32  : foo
1.2  : 123 : xyz
</code></pre>
</div>

<p><strong>Further Reading</strong></p>

<ul>
  <li><a href="http://www.skorks.com/2010/05/sort-files-like-a-master-with-the-linux-sort-command-bash/">sort like a master</a></li>
  <li><a href="https://unix.stackexchange.com/questions/tagged/sort?sort=votes&amp;pageSize=15">sort Q&amp;A on unix stackexchange</a></li>
  <li><a href="https://unix.stackexchange.com/questions/249452/unix-multiple-column-sort-issue">sort on multiple columns using -k option</a></li>
</ul>

<p><br /></p>

<h3 id="uniq"><a name="uniq"></a>uniq</h3>

<blockquote>
  <p>report or omit repeated lines</p>
</blockquote>

<p>This command is more specific to recognizing duplicates. Usually requires a sorted input as the comparison is made on adjacent lines only</p>

<p><strong>Options</strong></p>

<ul>
  <li><code class="highlighter-rouge">-d</code> print only duplicate lines</li>
  <li><code class="highlighter-rouge">-c</code> prefix count to occurrences</li>
  <li><code class="highlighter-rouge">-u</code> print only unique lines</li>
</ul>

<p><strong>Examples</strong></p>

<ul>
  <li><code class="highlighter-rouge">sort test_list.txt | uniq</code> outputs lines of test_list.txt in sorted order with duplicate lines removed
    <ul>
      <li><code class="highlighter-rouge">uniq &lt;(sort test_list.txt)</code> same command using process substitution</li>
      <li><code class="highlighter-rouge">sort -u test_list.txt</code> equivalent command</li>
    </ul>
  </li>
  <li><code class="highlighter-rouge">uniq -d sorted_list.txt</code> print only duplicate lines</li>
  <li><code class="highlighter-rouge">uniq -cd sorted_list.txt</code> print only duplicate lines and prefix the line with number of times it is repeated</li>
  <li><code class="highlighter-rouge">uniq -u sorted_list.txt</code> print only unique lines, repeated lines are ignored</li>
  <li><a href="http://unix.stackexchange.com/questions/tagged/uniq?sort=votes&amp;pageSize=15">uniq Q&amp;A on unix stackexchange</a></li>
</ul>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="gp">$ </span><span class="nb">echo</span> -e <span class="s1">'Blue\nRed\nGreen\nBlue\nRed\nBlack\nRed'</span> &gt; colors.txt 
<span class="gp">$ </span>uniq colors.txt 
Blue
Red
Green
Blue
Red
Black
Red

<span class="gp">$ </span><span class="nb">echo</span> -e <span class="s1">'Blue\nRed\nGreen\nBlue\nRed\nBlack\nRed'</span> | sort &gt; sorted_colors.txt 
<span class="gp">$ </span>uniq sorted_colors.txt
Black
Blue
Green
Red

<span class="gp">$ </span>uniq -d sorted_colors.txt 
Blue
Red

<span class="gp">$ </span>uniq -cd sorted_colors.txt 
      2 Blue
      3 Red
      
<span class="gp">$ </span>uniq -u sorted_colors.txt 
Black
Green
</code></pre>
</div>

<p><br /></p>

<h3 id="comm"><a name="comm"></a>comm</h3>

<blockquote>
  <p>compare two sorted files line by line</p>
</blockquote>

<p>Without any options, it prints output in three columns - lines unique to file1, line unique to file2 and lines common to both files</p>

<p><strong>Options</strong></p>

<ul>
  <li><code class="highlighter-rouge">-1</code> suppress lines unique to file1</li>
  <li><code class="highlighter-rouge">-2</code> suppress lines unique to file2</li>
  <li><code class="highlighter-rouge">-3</code> suppress lines common to both files</li>
</ul>

<p><strong>Examples</strong></p>

<ul>
  <li><code class="highlighter-rouge">comm -23 sorted_file1.txt sorted_file2.txt</code> print lines unique to sorted_file1.txt
    <ul>
      <li><code class="highlighter-rouge">comm -23 &lt;(sort file1.txt) &lt;(sort file2.txt)'</code> same command using process substitution, if sorted input files are not available</li>
    </ul>
  </li>
  <li><code class="highlighter-rouge">comm -13 sorted_file1.txt sorted_file2.txt</code> print lines unique to sorted_file2.txt</li>
  <li><code class="highlighter-rouge">comm -12 sorted_file1.txt sorted_file2.txt</code> print lines common to both files</li>
  <li><a href="http://unix.stackexchange.com/questions/tagged/comm?sort=votes&amp;pageSize=15">comm Q&amp;A on unix stackexchange</a></li>
</ul>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="gp">$ </span><span class="nb">echo</span> -e <span class="s1">'Brown\nRed\nPurple\nBlue\nTeal\nYellow'</span> | sort &gt; colors_1.txt 
<span class="gp">$ </span><span class="nb">echo</span> -e <span class="s1">'Red\nGreen\nBlue\nBlack\nWhite'</span> | sort &gt; colors_2.txt 

<span class="gp">$ </span><span class="c"># the input files viewed side by side</span>
<span class="gp">$ </span>paste colors_1.txt colors_2.txt
Blue    Black
Brown   Blue
Purple  Green
Red     Red
Teal    White
Yellow  
</code></pre>
</div>

<ul>
  <li>examples</li>
</ul>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="gp">$ </span><span class="c"># 3 column output - unique to file1, file2 and common</span>
<span class="gp">$ </span>comm colors_1.txt colors_2.txt
        Black
                Blue
Brown
        Green
Purple
                Red
Teal
        White
YellowÂ 

<span class="gp">$ </span><span class="c"># suppress 1 and 2 column, gives only common lines</span>
<span class="gp">$ </span>comm -12 colors_1.txt colors_2.txt
Blue
Red

<span class="gp">$ </span><span class="c"># suppress 1 and 3 column, gives lines unique to file2</span>
<span class="gp">$ </span>comm -13 colors_1.txt colors_2.txt
Black
Green
White

<span class="gp">$ </span><span class="c"># suppress 2 and 3 column, gives lines unique to file1</span>
<span class="gp">$ </span>comm -23 colors_1.txt colors_2.txt
Brown
Purple
Teal
Yellow
</code></pre>
</div>

<p><br /></p>

<h3 id="cmp"><a name="cmp"></a>cmp</h3>

<blockquote>
  <p>compare two files byte by byte</p>
</blockquote>

<p>Useful to compare binary files. If the two files are same, no output is displayed (exit status 0)<br />
If there is a difference, it prints the first difference - line number and byte location (exit status 1)<br />
Option <code class="highlighter-rouge">-s</code> allows to suppress the output, useful in scripts</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="gp">$ </span>cmp /bin/grep /bin/fgrep
/bin/grep /bin/fgrep differ: byte 25, line 1
</code></pre>
</div>

<ul>
  <li>More examples <a href="http://www.sanfoundry.com/5-cmp-command-usage-examples-linux/">here</a></li>
</ul>

<p><br /></p>

<h3 id="diff"><a name="diff"></a>diff</h3>

<blockquote>
  <p>compare files line by line</p>
</blockquote>

<p>Useful to compare old and new versions of text files<br />
All the differences are printed, which might not be desirable if files are too long</p>

<p><strong>Options</strong></p>

<ul>
  <li><code class="highlighter-rouge">-s</code> convey message when two files are same</li>
  <li><code class="highlighter-rouge">-y</code> two column output</li>
  <li><code class="highlighter-rouge">-i</code> ignore case while comparing</li>
  <li><code class="highlighter-rouge">-w</code> ignore white-spaces</li>
  <li><code class="highlighter-rouge">-r</code> recursively compare files between the two directories specified</li>
  <li><code class="highlighter-rouge">-q</code> report if files differ, not the details of difference</li>
</ul>

<p><strong>Examples</strong></p>

<ul>
  <li><code class="highlighter-rouge"><span class="gh">diff -s test_list_mar2.txt test_list_mar3.txt</span></code> compare two files</li>
  <li><code class="highlighter-rouge"><span class="gh">diff -s report.log bkp/mar10/</span></code> no need to specify second filename if names are same</li>
  <li><code class="highlighter-rouge"><span class="gh">diff -qr report/ bkp/mar10/report/</span></code> recursively compare files between report and bkp/mar10/report directories, filenames not matching are also specified in output
    <ul>
      <li>see <a href="https://stackoverflow.com/questions/6217628/diff-to-output-only-the-file-names">this link</a> for detailed analysis and corner cases</li>
    </ul>
  </li>
  <li><code class="highlighter-rouge"><span class="gh">diff report/ bkp/mar10/report/ | grep -w '^diff'</span></code> useful trick to get only names of mismatching files (provided no mismatches contain the whole word diff at start of line)</li>
</ul>

<p><strong>Further Reading</strong></p>

<ul>
  <li><a href="https://unix.stackexchange.com/questions/tagged/diff?sort=votes&amp;pageSize=15">diff Q&amp;A on unix stackexchange</a></li>
  <li><code class="highlighter-rouge">gvimdiff</code> edit two, three or four versions of a file with Vim and show differences</li>
  <li><a href="http://askubuntu.com/questions/2946/what-are-some-good-gui-diff-and-merge-applications-available-for-ubuntu">GUI diff and merge tools</a></li>
</ul>

<p><br /></p>

<h3 id="tr"><a name="tr"></a>tr</h3>

<blockquote>
  <p>translate or delete characters</p>
</blockquote>

<p><strong>Options</strong></p>

<ul>
  <li><code class="highlighter-rouge">-d</code> delete the specified characters</li>
  <li><code class="highlighter-rouge">-c</code> complement set of characters to be replaced</li>
</ul>

<p><strong>Examples</strong></p>

<ul>
  <li><code class="highlighter-rouge">tr a-z A-Z &lt; test_list.txt</code> convert lowercase to uppercase</li>
  <li><code class="highlighter-rouge">tr -d ._ &lt; test_list.txt</code> delete the dot and underscore characters</li>
  <li><code class="highlighter-rouge">tr a-z n-za-m &lt; test_list.txt &gt; encrypted_test_list.txt</code> Encrypt by replacing every lowercase alphabet with 13th alphabet after it
    <ul>
      <li>Same command on encrypted text will decrypt it</li>
    </ul>
  </li>
  <li><a href="http://unix.stackexchange.com/questions/tagged/tr?sort=votes&amp;pageSize=15">tr Q&amp;A on unix stackexchange</a></li>
</ul>

<p><br /></p>

<h3 id="sed"><a name="sed"></a>sed</h3>

<blockquote>
  <p>stream editor for filtering and transforming text</p>
</blockquote>

<p><strong>Options</strong></p>

<ul>
  <li><code class="highlighter-rouge">-n</code> suppress automatic printing of pattern space</li>
  <li><code class="highlighter-rouge">-i</code> edit files inplace (makes backup if SUFFIX supplied)</li>
  <li><code class="highlighter-rouge">-r</code> use extended regular expressions</li>
  <li><code class="highlighter-rouge">-e</code> add the script to the commands to be executed</li>
  <li><code class="highlighter-rouge">-f</code> add the contents of script-file to the commands to be executed
    <ul>
      <li>for examples and details, refer to links given below</li>
    </ul>
  </li>
</ul>

<p><strong>commands</strong></p>

<p>Weâ€™ll be seeing examples only for three commonly used commands</p>

<ul>
  <li><code class="highlighter-rouge">d</code> Delete the pattern space</li>
  <li><code class="highlighter-rouge">p</code> Print out the pattern space</li>
  <li><code class="highlighter-rouge">s</code> search and replace</li>
  <li>check out â€˜Often-Used Commandsâ€™ and â€˜Less Frequently-Used Commandsâ€™ sections in <code class="highlighter-rouge">info sed</code> for complete list of commands</li>
</ul>

<p><strong>range</strong></p>

<p>By default, <code class="highlighter-rouge">sed</code> acts on all of input contents. This can be refined to specific line number or a range defined by line numbers, search pattern or mix of the two</p>

<ul>
  <li><code class="highlighter-rouge">n,m</code> range between nth line to mth line, including n and m</li>
  <li><code class="highlighter-rouge">i~j</code> act on ith line and i+j, i+2j, i+3j, etc
    <ul>
      <li><code class="highlighter-rouge">1~2</code> means 1st, 3rd, 5th, 7th, etc lines i.e odd numbered lines</li>
      <li><code class="highlighter-rouge">5~3</code> means 5th, 8th, 11th, etc</li>
    </ul>
  </li>
  <li><code class="highlighter-rouge">n</code> only nth line</li>
  <li><code class="highlighter-rouge">$</code> only last line</li>
  <li><code class="highlighter-rouge">/pattern/</code> lines matching pattern</li>
  <li><code class="highlighter-rouge">n,/pattern/</code> nth line to line matching pattern</li>
  <li><code class="highlighter-rouge">n,+x</code> nth line and x lines after</li>
  <li><code class="highlighter-rouge">/pattern/,m</code> line matching pattern to mth line</li>
  <li><code class="highlighter-rouge">/pattern/,+x</code> line matching pattern and x lines after</li>
  <li><code class="highlighter-rouge">/pattern1/,/pattern2/</code> line matching pattern1 to line matching pattern2</li>
  <li><code class="highlighter-rouge">/pattern/I</code> lines matching pattern, pattern is case insensitive</li>
  <li>for more details, see section â€˜Selecting lines with sedâ€™ in <code class="highlighter-rouge">info sed</code></li>
  <li>see â€˜Regular Expressionsâ€™ in <a href="https://github.com/learnbyexample/Linux_command_line/blob/master/Working_with_Files_and_Directories.md#grep">grep command</a> for extended regular expressions reference</li>
  <li>also check out â€˜Overview of Regular Expression Syntaxâ€™ section in <code class="highlighter-rouge">info sed</code></li>
</ul>

<p><strong>Examples for selective deletion(d)</strong></p>

<ul>
  <li><code class="highlighter-rouge">sed '/cat/d' story.txt</code> delete every line containing cat</li>
  <li><code class="highlighter-rouge">sed '/cat/!d' story.txt</code> delete every line NOT containing cat</li>
  <li><code class="highlighter-rouge">sed '$d' story.txt</code> delete last line of the file</li>
  <li><code class="highlighter-rouge">sed '2,5d' story.txt</code> delete lines 2,3,4,5 of the file</li>
  <li><code class="highlighter-rouge">sed '1,/test/d' dir_list.txt</code> delete all lines from beginning of file to first occurrence of line containing test (the matched line is also deleted)</li>
  <li><code class="highlighter-rouge">sed '/test/,$d' dir_list.txt</code> delete all lines from line containing test to end of file</li>
</ul>

<p><strong>Examples for selective printing(p)</strong></p>

<ul>
  <li><code class="highlighter-rouge">sed -n '5p' story.txt</code> print 5th line, <code class="highlighter-rouge">-n</code> option overrides default print behavior of sed
    <ul>
      <li>use <code class="highlighter-rouge">sed '5q;d' story.txt</code> on large files. <a href="https://stackoverflow.com/questions/191364/quick-unix-command-to-display-specific-lines-in-the-middle-of-a-file/17367226#17367226">Read more</a></li>
    </ul>
  </li>
  <li><code class="highlighter-rouge">sed -n '/cat/p' story.txt</code> print every line containing the text cat
    <ul>
      <li>equivalent to <code class="highlighter-rouge">sed '/cat/!d' story.txt</code></li>
    </ul>
  </li>
  <li><code class="highlighter-rouge">sed -n '4,8!p' story.txt</code> print all lines except lines 4 to 8</li>
  <li><code class="highlighter-rouge">man grep | sed -n '/^\s*exit status/I,/^$/p'</code> extract exit status information of a command from manual
    <ul>
      <li><code class="highlighter-rouge">/^\s*exit status/I</code> checks for line starting with â€˜exit statusâ€™ in case insensitive way, white-space may be present at start of line</li>
      <li><code class="highlighter-rouge">/^$/</code> empty line</li>
    </ul>
  </li>
  <li><code class="highlighter-rouge">man ls | sed -n '/^\s*-F/,/^$/p'</code> extract information on command option from manual
    <ul>
      <li><code class="highlighter-rouge">/^\s*-F/</code> line starting with option â€˜-Fâ€™, white-space may be present at start of line</li>
    </ul>
  </li>
</ul>

<p><strong>Examples for search and replace(s)</strong></p>

<ul>
  <li><code class="highlighter-rouge">sed -i 's/cat/dog/g' story.txt</code> search and replace every occurrence of cat with dog in story.txt</li>
  <li><code class="highlighter-rouge">sed -i.bkp 's/cat/dog/g' story.txt</code> in addition to inplace file editing, create backup file story.txt.bkp, so that if a mistake happens, original file can be restored
    <ul>
      <li><code class="highlighter-rouge">sed -i.bkp 's/cat/dog/g' *.txt</code> to perform operation on all files ending with .txt in current directory</li>
    </ul>
  </li>
  <li><code class="highlighter-rouge">sed -i '5,10s/cat/dog/gI' story.txt</code> search and replace every occurrence of cat (case insensitive due to modifier I) with dog in story.txt only in line numbers 5 to 10</li>
  <li><code class="highlighter-rouge">sed '/cat/ s/animal/mammal/g' story.txt</code> replace animal with mammal in all lines containing cat
    <ul>
      <li>Since <code class="highlighter-rouge">-i</code> option is not used, output is displayed on standard output and story.txt is not changed</li>
      <li>spacing between range and command is optional, <code class="highlighter-rouge">sed '/cat/s/animal/mammal/g' story.txt</code> can also be used</li>
    </ul>
  </li>
  <li><code class="highlighter-rouge">sed -i -e 's/cat/dog/g' -e 's/lion/tiger/g' story.txt</code> search and replace every occurrence of cat with dog and lion with tiger
    <ul>
      <li>any number of <code class="highlighter-rouge">-e</code> option can be used</li>
      <li><code class="highlighter-rouge">sed -i 's/cat/dog/g ; s/lion/tiger/g' story.txt</code> alternative syntax, spacing around ; is optional</li>
    </ul>
  </li>
  <li><code class="highlighter-rouge">sed -r 's/(.*)/abc: \1 :xyz/' list.txt</code> add prefix â€˜abc: â€˜ and suffix â€˜ :xyzâ€™ to every line of list.txt</li>
  <li><code class="highlighter-rouge">sed -i -r "s/(.*)/$(basename $PWD)\/\1/" dir_list.txt</code> add current directory name and forward-slash character at the start of every line
    <ul>
      <li>Note the use of double quotes to perform command substitution</li>
    </ul>
  </li>
  <li><code class="highlighter-rouge">sed -i -r "s|.*|$HOME/\0|" dir_list.txt</code> add home directory and forward-slash at the start of every line
    <ul>
      <li>Since the value of â€˜$HOMEâ€™ itself contains forward-slash characters, we cannot use <code class="highlighter-rouge">/</code> as delimiter</li>
      <li>Any character other than backslash or newline can be used as delimiter, for example <code class="highlighter-rouge">| # ^</code> <a href="https://stackoverflow.com/questions/33914360/what-delimiters-can-you-use-in-sed">see this link for more info</a></li>
      <li><code class="highlighter-rouge">\0</code> back-reference contains entire matched string</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<p><strong>Example input file</strong></p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="gp">$ </span>cat mem_test.txt 
mreg2 <span class="o">=</span> 1200 <span class="c"># starting address</span>
mreg4 <span class="o">=</span> 2180 <span class="c"># ending address</span>

dreg5 <span class="o">=</span> get<span class="o">(</span>mreg2<span class="o">)</span> + get<span class="o">(</span>mreg4<span class="o">)</span>
print dreg5
</code></pre>
</div>

<ul>
  <li>replace all <strong>reg</strong> with <strong>register</strong></li>
</ul>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="gp">$ </span>sed <span class="s1">'s/reg/register/g'</span> mem_test.txt 
mregister2 <span class="o">=</span> 1200 <span class="c"># starting address</span>
mregister4 <span class="o">=</span> 2180 <span class="c"># ending address</span>

dregister5 <span class="o">=</span> get<span class="o">(</span>mregister2<span class="o">)</span> + get<span class="o">(</span>mregister4<span class="o">)</span>
print dregister5
</code></pre>
</div>

<ul>
  <li>change start and end address</li>
</ul>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="gp">$ </span>sed <span class="s1">'s/1200/1530/; s/2180/1870/'</span> mem_test.txt 
mreg2 <span class="o">=</span> 1530 <span class="c"># starting address</span>
mreg4 <span class="o">=</span> 1870 <span class="c"># ending address</span>

dreg5 <span class="o">=</span> get<span class="o">(</span>mreg2<span class="o">)</span> + get<span class="o">(</span>mreg4<span class="o">)</span>
print dreg5

<span class="gp">$ </span><span class="c"># to make changes only on mreg initializations, use</span>
<span class="gp">$ </span><span class="c"># sed '/mreg[0-9] *=/ s/1200/1530/; s/2180/1870/' mem_test.txt</span>
</code></pre>
</div>

<ul>
  <li>Using <code class="highlighter-rouge">bash</code> variables</li>
</ul>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="gp">$ </span><span class="nv">s_add</span><span class="o">=</span><span class="s1">'1760'</span>; <span class="nv">e_add</span><span class="o">=</span><span class="s1">'2500'</span>
<span class="gp">$ </span>sed <span class="s2">"s/1200/</span><span class="nv">$s_add</span><span class="s2">/; s/2180/</span><span class="nv">$e_add</span><span class="s2">/"</span> mem_test.txt 
mreg2 <span class="o">=</span> 1760 <span class="c"># starting address</span>
mreg4 <span class="o">=</span> 2500 <span class="c"># ending address</span>

dreg5 <span class="o">=</span> get<span class="o">(</span>mreg2<span class="o">)</span> + get<span class="o">(</span>mreg4<span class="o">)</span>
print dreg5
</code></pre>
</div>

<ul>
  <li>split inline commented code to comment + code</li>
</ul>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="gp">$ </span>sed -E <span class="s1">'s/^([^#]+)(#.*)/\2\n\1/'</span> mem_test.txt 
<span class="c"># starting address</span>
mreg2 <span class="o">=</span> 1200 
<span class="c"># ending address</span>
mreg4 <span class="o">=</span> 2180 

dreg5 <span class="o">=</span> get<span class="o">(</span>mreg2<span class="o">)</span> + get<span class="o">(</span>mreg4<span class="o">)</span>
print dreg5
</code></pre>
</div>

<ul>
  <li>range of lines matching pattern</li>
</ul>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="gp">$ </span>seq 20 | sed -n <span class="s1">'/3/,/5/p'</span>
3
4
5
13
14
15

</code></pre>
</div>

<ul>
  <li>inplace editing</li>
</ul>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="gp">$ </span>sed -i -E <span class="s1">'s/([md]r)eg/\1/g'</span> mem_test.txt
<span class="gp">$ </span>cat mem_test.txt
mr2 <span class="o">=</span> 1200 <span class="c"># starting address</span>
mr4 <span class="o">=</span> 2180 <span class="c"># ending address</span>

dr5 <span class="o">=</span> get<span class="o">(</span>mr2<span class="o">)</span> + get<span class="o">(</span>mr4<span class="o">)</span>
print dr5

<span class="gp">$ </span><span class="c"># more than one input files can be given</span>
<span class="gp">$ </span><span class="c"># use glob pattern if files share commonality, ex: *.txt</span>
</code></pre>
</div>

<p><strong>Further Reading</strong></p>

<ul>
  <li><a href="http://code.snipcademy.com/tutorials/shell-scripting/sed/introduction">sed basics</a></li>
  <li><a href="http://www.grymoire.com/Unix/Sed.html">sed detailed tutorial</a></li>
  <li><a href="http://www.catonmat.net/blog/sed-book/">sed-book</a></li>
  <li><a href="http://www.catonmat.net/download/sed.stream.editor.cheat.sheet.txt">cheat sheet</a></li>
  <li><a href="http://how-to.linuxcareer.com/learning-linux-commands-sed">sed examples</a></li>
  <li><a href="http://www.catonmat.net/series/sed-one-liners-explained">sed one-liners explained</a></li>
  <li><a href="https://unix.stackexchange.com/questions/112023/how-can-i-replace-a-string-in-a-files">common search and replace examples with sed</a></li>
  <li><a href="https://unix.stackexchange.com/questions/tagged/sed?sort=votes&amp;pageSize=15">sed Q&amp;A on unix stackexchange</a></li>
  <li><a href="https://stackoverflow.com/questions/tagged/sed?sort=votes&amp;pageSize=15">sed Q&amp;A on stackoverflow</a></li>
</ul>

<p><br /></p>

<h3 id="awk"><a name="awk"></a>awk</h3>

<blockquote>
  <p>pattern scanning and text processing language</p>
</blockquote>

<p><code class="highlighter-rouge">awk</code> derives its name from authors Alfred Aho, Peter Weinberger and Brian Kernighan.</p>

<p><strong>syntax</strong></p>

<ul>
  <li><code class="highlighter-rouge">awk 'BEGIN {initialize} condition1 {stmts} condition2 {stmts}... END {finish}'</code>
    <ul>
      <li><code class="highlighter-rouge">BEGIN {initialize}</code> used to initialize variables (could be user defined or awk variables or both), executed once - optional block</li>
      <li><code class="highlighter-rouge">condition1 {stmts} condition2 {stmts}...</code> action performed for every line of input, condition is optional, more than one block {} can be used with/without condition</li>
      <li><code class="highlighter-rouge">END {finish}</code> perform action once at end of program - optional block</li>
    </ul>
  </li>
  <li>commands can be written in a file and passed using the <code class="highlighter-rouge">-f</code> option instead of writing it all on command line
    <ul>
      <li>for examples and details, refer to links given below</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<p><strong>Example input file</strong></p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="gp">$ </span>cat test.txt 
abc  : 123 : xyz
3    : 32  : foo
-2.3 : bar : bar
</code></pre>
</div>

<ul>
  <li>Just printing something, no input</li>
</ul>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="gp">$ </span>awk <span class="s1">'BEGIN{print "Hello!\nTesting awk one-liner"}'</span>
Hello!
Testing awk one-liner
</code></pre>
</div>

<ul>
  <li>search and replace</li>
  <li>when the <code class="highlighter-rouge"><span class="p">{</span><span class="err">stmts</span><span class="p">}</span></code> portion of <code class="highlighter-rouge">condition {stmts}</code> is not specified, by default <code class="highlighter-rouge"><span class="p">{</span><span class="err">print</span><span class="w"> </span><span class="err">$0</span><span class="p">}</span></code> is executed if the <code class="highlighter-rouge">condition</code> evaluates to true
    <ul>
      <li><code class="highlighter-rouge">1</code> is a generally used <code class="highlighter-rouge">awk</code> idiom to print contents of <code class="highlighter-rouge">$0</code> after performing some processing</li>
      <li><code class="highlighter-rouge">print</code> statement without argument will print the content of <code class="highlighter-rouge">$0</code></li>
    </ul>
  </li>
</ul>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="gp">$ </span><span class="c"># sub will replace only first occurrence</span>
<span class="gp">$ </span><span class="c"># third argument to sub specifies variable to change, defaults to $0</span>
<span class="gp">$ </span>awk <span class="s1">'{sub("3", "%")} 1'</span> test.txt 
abc  : 12% : xyz
<span class="gp">%    </span>: 32  : foo
<span class="gp">-2.% </span>: bar : bar

<span class="gp">$ </span><span class="c"># gsub will replace all occurrences</span>
<span class="gp">$ </span>awk <span class="s1">'{gsub("3", "%")} 1'</span> test.txt 
abc  : 12% : xyz
<span class="gp">%    </span>: %2  : foo
<span class="gp">-2.% </span>: bar : bar

<span class="gp">$ </span><span class="c"># add a condition to restrict processing only to those records</span>
<span class="gp">$ </span>awk <span class="s1">'/foo/{gsub("3", "%")} 1'</span> test.txt 
abc  : 123 : xyz
<span class="gp">%    </span>: %2  : foo
-2.3 : bar : bar

<span class="gp">$ </span><span class="c"># using shell variables</span>
<span class="gp">$ </span><span class="nv">r</span><span class="o">=</span><span class="s2">"@"</span>
<span class="gp">$ </span>awk -v <span class="nv">r_str</span><span class="o">=</span><span class="s2">"</span><span class="nv">$r</span><span class="s2">"</span> <span class="s1">'{sub("3", r_str)} 1'</span> test.txt 
abc  : 12@ : xyz
@    : 32  : foo
-2.@ : bar : bar

<span class="gp">$ </span><span class="c"># bash environment variables like PWD, HOME is also accessible via ENVIRON</span>
<span class="gp">$ </span><span class="nv">s</span><span class="o">=</span><span class="s2">"%"</span> awk <span class="s1">'{sub("3", ENVIRON["s"])} 1'</span> test.txt 
abc  : 12% : xyz
<span class="gp">%    </span>: 32  : foo
<span class="gp">-2.% </span>: bar : bar
</code></pre>
</div>

<ul>
  <li>filtering content</li>
</ul>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="gp">$ </span><span class="c"># regex pattern, by default tested against $0</span>
<span class="gp">$ </span>awk <span class="s1">'/a/'</span> test.txt 
abc  : 123 : xyz
-2.3 : bar : bar

<span class="gp">$ </span><span class="c"># use ! to invert condition</span>
<span class="gp">$ </span>awk <span class="s1">'!/abc/'</span> test.txt 
3    : 32  : foo
-2.3 : bar : bar

<span class="gp">$ </span>seq 30 | awk <span class="s1">'END{print}'</span>
30

<span class="gp">$ </span><span class="c"># generic, length(var) - default is $0</span>
<span class="gp">$ </span>seq 8 13 | awk <span class="s1">'length==1'</span>
8
9
</code></pre>
</div>

<ul>
  <li>selecting based on line numbers</li>
  <li><code class="highlighter-rouge">NR</code> is record number</li>
</ul>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="gp">$ </span>seq 123 135 | awk <span class="s1">'NR==7'</span>
129

<span class="gp">$ </span>seq 123 135 | awk <span class="s1">'NR&gt;=3 &amp;&amp; NR&lt;=5'</span>
125
126
127

<span class="gp">$ </span>seq 5 | awk <span class="s1">'NR&gt;=3'</span>
3
4
5

<span class="gp">$ </span><span class="c"># for large input, use exit to avoid unnecessary record processing</span>
<span class="gp">$ </span>seq 14323 14563435 | awk <span class="s1">'NR==234{print; exit}'</span>
14556
</code></pre>
</div>

<ul>
  <li>selecting based on start and end condition</li>
  <li>for following examples
    <ul>
      <li>numbers 1 to 20 is input</li>
      <li>regex pattern <code class="highlighter-rouge">/4/</code> is start condition</li>
      <li>regex pattern <code class="highlighter-rouge">/6/</code> is end condition</li>
    </ul>
  </li>
  <li><code class="highlighter-rouge">f</code> is idiomatically used to represent a flag variable</li>
</ul>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="gp">$ </span><span class="c"># records between start and end</span>
<span class="gp">$ </span>seq 20 | awk <span class="s1">'/4/{f=1; next} /6/{f=0} f'</span>
5
15

<span class="gp">$ </span><span class="c"># records between start and end and also includes start</span>
<span class="gp">$ </span>seq 20 | awk <span class="s1">'/4/{f=1} /6/{f=0} f'</span>
4
5
14
15

<span class="gp">$ </span><span class="c"># records between start and end and also includes end</span>
<span class="gp">$ </span>seq 20 | awk <span class="s1">'/4/{f=1; next} f; /6/{f=0}'</span>
5
6
15
16

<span class="gp">$ </span><span class="c"># records from start to end</span>
<span class="gp">$ </span>seq 20 | awk <span class="s1">'/4/{f=1} f{print} /6/{f=0}'</span>
4
5
6
14
15
16

<span class="gp">$ </span><span class="c"># records excluding start to end</span>
<span class="gp">$ </span>seq 10 | awk <span class="s1">'/4/{f=1} !f; /6/{f=0}'</span>
1
2
3
7
8
9
10
</code></pre>
</div>

<ul>
  <li>column manipulations</li>
  <li>by default, one or more consecutive spaces/tabs are considered as field separators</li>
</ul>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="gp">$ </span><span class="nb">echo</span> -e <span class="s2">"1 3 4</span><span class="se">\n</span><span class="s2">a b c"</span>
1 3 4
a b c

<span class="gp">$ </span><span class="c"># second column</span>
<span class="gp">$ </span><span class="nb">echo</span> -e <span class="s2">"1 3 4</span><span class="se">\n</span><span class="s2">a b c"</span> | awk <span class="s1">'{print $2}'</span>
3
b

<span class="gp">$ </span><span class="c"># last column</span>
<span class="gp">$ </span><span class="nb">echo</span> -e <span class="s2">"1 3 4</span><span class="se">\n</span><span class="s2">a b c"</span> | awk <span class="s1">'{print $NF}'</span>
4
c

<span class="gp">$ </span><span class="c"># default output field separator is single space character</span>
<span class="gp">$ </span><span class="nb">echo</span> -e <span class="s2">"1 3 4</span><span class="se">\n</span><span class="s2">a b c"</span> | awk <span class="s1">'{print $1, $3}'</span>
1 4
a c

<span class="gp">$ </span><span class="c"># condition for specific field</span>
<span class="gp">$ </span><span class="nb">echo</span> -e <span class="s2">"1 3 4</span><span class="se">\n</span><span class="s2">a b c"</span> | awk <span class="s1">'$2 ~ /[0-9]/'</span>
1 3 4
</code></pre>
</div>

<ul>
  <li>specifying a different input/output field separator</li>
  <li>can be string alone or regex, multiple separators can be specified using <code class="highlighter-rouge">|</code> in regex pattern</li>
</ul>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="gp">$ </span>awk -F<span class="s1">' *: *'</span> <span class="s1">'$1 == "3"'</span> test.txt 
3    : 32  : foo

<span class="gp">$ </span>awk -F<span class="s1">' *: *'</span> <span class="s1">'{print $1 "," $2}'</span> test.txt 
abc,123
3,32
-2.3,bar

<span class="gp">$ </span>awk -F<span class="s1">' *: *'</span> -v <span class="nv">OFS</span><span class="o">=</span><span class="s2">"::"</span> <span class="s1">'{print $1, $2}'</span> test.txt 
abc::123
3::32
-2.3::bar

<span class="gp">$ </span>awk -F: -v <span class="nv">OFS</span><span class="o">=</span><span class="s2">"</span><span class="se">\t</span><span class="s2">"</span> <span class="s1">'{print $1 OFS $2}'</span> test.txt 
abc  	 123 
3    	 32  
-2.3 	 bar 
</code></pre>
</div>

<ul>
  <li>dealing with duplicates, line/field wise</li>
</ul>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="gp">$ </span>cat duplicates.txt 
abc 123 ijk
foo 567 xyz
abc 123 ijk
bar 090 pqr
tst 567 zzz

<span class="gp">$ </span><span class="c"># whole line</span>
<span class="gp">$ </span>awk <span class="s1">'!seen[$0]++'</span> duplicates.txt 
abc 123 ijk
foo 567 xyz
bar 090 pqr
tst 567 zzz

<span class="gp">$ </span><span class="c"># particular column</span>
<span class="gp">$ </span>awk <span class="s1">'!seen[$2]++'</span> duplicates.txt 
abc 123 ijk
foo 567 xyz
bar 090 pqr
</code></pre>
</div>

<ul>
  <li>inplace editing</li>
</ul>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="gp">$ </span>awk -i inplace <span class="s1">'{print NR ") " $0}'</span> test.txt
<span class="gp">$ </span>cat test.txt
1<span class="o">)</span> abc  : 123 : xyz
2<span class="o">)</span> 3    : 32  : foo
3<span class="o">)</span> -2.3 : bar : bar
</code></pre>
</div>

<p><strong>Further Reading</strong></p>

<ul>
  <li><a href="http://code.snipcademy.com/tutorials/shell-scripting/awk/introduction">awk basics</a></li>
  <li><a href="https://www.gnu.org/software/gawk/manual/">Gawk: Effective AWK Programming</a></li>
  <li><a href="http://www.grymoire.com/Unix/Awk.html">awk detailed tutorial</a></li>
  <li><a href="https://unix.stackexchange.com/questions/2434/is-there-a-basic-tutorial-for-grep-awk-and-sed">basic tutorials for grep, awk, sed</a></li>
  <li><a href="http://www.catonmat.net/series/awk-one-liners-explained">awk one-liners explained</a></li>
  <li><a href="http://www.catonmat.net/blog/awk-book/">awk book</a></li>
  <li><a href="http://www.catonmat.net/download/awk.cheat.sheet.txt">awk cheat-sheet</a> for awk variables, statements, functions, etc</li>
  <li><a href="http://www.thegeekstuff.com/tag/unix-awk-examples/">awk examples</a></li>
  <li><a href="https://unix.stackexchange.com/questions/tagged/awk?sort=votes&amp;pageSize=15">awk Q&amp;A on unix stackexchange</a></li>
  <li><a href="https://stackoverflow.com/questions/tagged/awk?sort=votes&amp;pageSize=15">awk Q&amp;A on stackoverflow</a></li>
</ul>

<p><br /></p>

<h3 id="perl"><a name="perl"></a>perl</h3>

<blockquote>
  <p>The Perl 5 language interpreter</p>
</blockquote>

<p><a href="https://en.wikipedia.org/wiki/Larry_Wall">Larry Wall</a> wrote Perl as a <strong>general purpose scripting language</strong>, borrowing features from <strong>C, shell scripting, awk, sed, grep, cut, sort</strong> etc</p>

<p>Reference tables given below for frequently used constructs with <strong>perl one-liners</strong>. Resource links given at end for further reading.</p>

<p><br /></p>

<p>Descriptions adapted from <a href="http://perldoc.perl.org/perlrun.html#Command-Switches">perldoc - command switches</a></p>

<table>
  <thead>
    <tr>
      <th>Option</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>-e</td>
      <td>execute perl code</td>
    </tr>
    <tr>
      <td>-n</td>
      <td>iterate over input files in a loop, lines are NOT printed by default</td>
    </tr>
    <tr>
      <td>-p</td>
      <td>iterate over input files in a loop, lines are printed by default</td>
    </tr>
    <tr>
      <td>-l</td>
      <td>chomp input line, $\ gets value of $/ if no argument given</td>
    </tr>
    <tr>
      <td>-a</td>
      <td>autosplit input lines on space, implicitly sets -n for Perl version 5.20.0 and above</td>
    </tr>
    <tr>
      <td>-F</td>
      <td>specifies the pattern to split input lines, implicitly sets -a and -n for Perl version 5.20.0 and above</td>
    </tr>
    <tr>
      <td>-i</td>
      <td>edit files inplace, if extension provided make a backup copy</td>
    </tr>
    <tr>
      <td>-0777</td>
      <td>slurp entire file as single string, not advisable for large input files</td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<p>Descriptions adapted from <a href="http://perldoc.perl.org/perlvar.html#SPECIAL-VARIABLES">perldoc - Special Variables</a></p>

<table>
  <thead>
    <tr>
      <th>Variable</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>$_</td>
      <td>The default input and pattern-searching space</td>
    </tr>
    <tr>
      <td>$.</td>
      <td>Current line number</td>
    </tr>
    <tr>
      <td>$/</td>
      <td>input record separator, newline by default</td>
    </tr>
    <tr>
      <td>$\</td>
      <td>output record separator, empty string by default</td>
    </tr>
    <tr>
      <td>@F</td>
      <td>contains the fields of each line read, applicable with -a or -F option</td>
    </tr>
    <tr>
      <td>%ENV</td>
      <td>contains current environment variables</td>
    </tr>
    <tr>
      <td>$ARGV</td>
      <td>contains the name of the current file</td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<table>
  <thead>
    <tr>
      <th>Function</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>length</td>
      <td>Returns the length in characters of the value of EXPR. If EXPR is omitted, returns the length of $_</td>
    </tr>
    <tr>
      <td>eof</td>
      <td>Returns 1 if the next read on FILEHANDLE will return end of file</td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<p><strong>Simple Perl program</strong></p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="gp">$ </span>perl -e <span class="s1">'print "Hello!\nTesting Perl one-liner\n"'</span>
Hello!
Testing Perl one-liner
</code></pre>
</div>

<p><br /></p>

<p><strong>Example input file</strong></p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="gp">$ </span>cat test.txt 
abc  : 123 : xyz
3    : 32  : foo
-2.3 : bar : bar
</code></pre>
</div>

<p><br /></p>

<ul>
  <li>Search and replace</li>
</ul>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="gp">$ </span>perl -pe <span class="s1">'s/3/%/'</span> test.txt
abc  : 12% : xyz
<span class="gp">%    </span>: 32  : foo
<span class="gp">-2.% </span>: bar : bar

<span class="gp">$ </span><span class="c"># use g flag to replace all occurrences, not just first match in line</span>
<span class="gp">$ </span>perl -pe <span class="s1">'s/3/%/g'</span> test.txt
abc  : 12% : xyz
<span class="gp">%    </span>: %2  : foo
<span class="gp">-2.% </span>: bar : bar

<span class="gp">$ </span><span class="c"># conditional replacement</span>
<span class="gp">$ </span>perl -pe <span class="s1">'s/3/@/g if /foo/'</span> test.txt 
abc  : 123 : xyz
@    : @2  : foo
-2.3 : bar : bar

<span class="gp">$ </span><span class="c"># using shell variables</span>
<span class="gp">$ </span><span class="nv">r</span><span class="o">=</span><span class="s2">"@"</span>
<span class="gp">$ </span>perl -pe <span class="s2">"s/3/</span><span class="nv">$r</span><span class="s2">/"</span> test.txt 
abc  : 12@ : xyz
@    : 32  : foo
-2.@ : bar : bar

<span class="gp">$ </span><span class="c"># preferred approach is to use ENV hash variable</span>
<span class="gp">$ </span><span class="nb">export </span><span class="nv">s</span><span class="o">=</span><span class="s2">"%"</span>
<span class="gp">$ </span>perl -pe <span class="s1">'s/3/$ENV{s}/'</span> test.txt 
abc  : 12% : xyz
<span class="gp">%    </span>: 32  : foo
<span class="gp">-2.% </span>: bar : bar
</code></pre>
</div>

<p><br /></p>

<ul>
  <li>Search and replace special characters</li>
</ul>

<p>The <code class="highlighter-rouge">\Q</code> and <code class="highlighter-rouge">q()</code> constructs are helpful to nullify regex meta characters</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="gp">$ </span><span class="c"># if not properly escaped or quoted, it can lead to errors</span>
<span class="gp">$ </span><span class="nb">echo</span> <span class="s1">'*.^[}'</span> | perl -pe <span class="s1">'s/*.^[}/abc/'</span>
Quantifier follows nothing <span class="k">in </span>regex; marked by &lt;-- HERE <span class="k">in </span>m/<span class="k">*</span> &lt;-- HERE .^[<span class="o">}</span>/ at -e line 1.

<span class="gp">$ </span><span class="nb">echo</span> <span class="s1">'*.^[}'</span> | perl -pe <span class="s1">'s/\*\.\^\[}/abc/'</span>
abc

<span class="gp">$ </span><span class="nb">echo</span> <span class="s1">'*.^[}'</span> | perl -pe <span class="s1">'s/\Q*.^[}/abc/'</span>
abc

<span class="gp">$ </span><span class="nb">echo</span> <span class="s1">'*.^[}'</span> | perl -pe <span class="s1">'s/\Q*.^[}/\$abc\$/'</span>
<span class="nv">$abc</span><span class="err">$</span>

<span class="gp">$ </span><span class="nb">echo</span> <span class="s1">'*.^[}'</span> | perl -pe <span class="s1">'s/\Q*.^[}/q($abc$)/e'</span>
<span class="nv">$abc</span><span class="err">$</span>
</code></pre>
</div>

<p><br /></p>

<ul>
  <li>Print lines based on line number or pattern</li>
</ul>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="gp">$ </span>perl -ne <span class="s1">'print if /a/'</span> test.txt 
abc  : 123 : xyz
-2.3 : bar : bar

<span class="gp">$ </span>perl -ne <span class="s1">'print if !/abc/'</span> test.txt 
3    : 32  : foo
-2.3 : bar : bar

<span class="gp">$ </span>seq 123 135 | perl -ne <span class="s1">'print if $. == 7'</span>
129

<span class="gp">$ </span>seq 1 30 | perl -ne <span class="s1">'print if eof'</span>
30

<span class="gp">$ </span><span class="c"># Use exit to save time on large input files</span>
<span class="gp">$ </span>seq 14323 14563435 | perl -ne <span class="s1">'if($. == 234){print; exit}'</span>
14556

<span class="gp">$ </span><span class="c"># length() can also be used instead of length $_</span>
<span class="gp">$ </span>seq 8 13 | perl -lne <span class="s1">'print if length $_ == 1'</span>
8
9
</code></pre>
</div>

<p><br /></p>

<ul>
  <li>Print range of lines based on line number or pattern</li>
</ul>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="gp">$ </span>seq 123 135 | perl -ne <span class="s1">'print if $. &gt;= 3 &amp;&amp; $. &lt;= 5'</span>
125
126
127

<span class="gp">$ </span><span class="c"># $. is default variable compared against when using ..</span>
<span class="gp">$ </span>seq 123 135 | perl -ne <span class="s1">'print if 3..5'</span>
125
126
127

<span class="gp">$ </span><span class="c"># can use many alternatives, eof looks more readable</span>
<span class="gp">$ </span>seq 5 | perl -ne <span class="s1">'print if 3..eof'</span>
3
4
5

<span class="gp">$ </span><span class="c"># matching regex specified by /pattern/ is checked against $_</span>
<span class="gp">$ </span>seq 5 | perl -ne <span class="s1">'print if 3../4/'</span>
3
4

<span class="gp">$ </span>seq 1 30 | perl -ne <span class="s1">'print if /4/../6/'</span>
4
5
6
14
15
16
24
25
26

<span class="gp">$ </span>seq 2 8 | perl -ne <span class="s1">'print if !(/4/../6/)'</span>
2
3
7
8
</code></pre>
</div>

<p><br /></p>

<ul>
  <li><code class="highlighter-rouge">..</code> vs <code class="highlighter-rouge">...</code></li>
</ul>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="gp">$ </span><span class="nb">echo</span> -e <span class="s1">'10\n11\n10'</span> | perl -ne <span class="s1">'print if /10/../10/'</span>
10
10

<span class="gp">$ </span><span class="nb">echo</span> -e <span class="s1">'10\n11\n10'</span> | perl -ne <span class="s1">'print if /10/.../10/'</span>
10
11
10
</code></pre>
</div>

<p><br /></p>

<ul>
  <li>Column manipulations</li>
</ul>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="gp">$ </span><span class="nb">echo</span> -e <span class="s2">"1 3 4</span><span class="se">\n</span><span class="s2">a b c"</span> | perl -nale <span class="s1">'print $F[1]'</span>
3
b

<span class="gp">$ </span><span class="nb">echo</span> -e <span class="s2">"1,3,4,8</span><span class="se">\n</span><span class="s2">a,b,c,d"</span> | perl -F, -lane <span class="s1">'print $F[$#F]'</span>
8
d

<span class="gp">$ </span>perl -F: -lane <span class="s1">'print "$F[0] $F[2]"'</span> test.txt 
abc    xyz
3      foo
-2.3   bar

<span class="gp">$ </span>perl -F: -lane <span class="s1">'$sum+=$F[1]; END{print $sum}'</span> test.txt 
155

<span class="gp">$ </span>perl -F: -lane <span class="s1">'$F[2] =~ s/\w(?=\w)/$&amp;,/g; print join ":", @F'</span> test.txt 
abc  : 123 : x,y,z
3    : 32  : f,o,o
-2.3 : bar : b,a,r

<span class="gp">$ </span>perl -F<span class="s1">'/:\s*[a-z]+/i'</span> -lane <span class="s1">'print $F[0]'</span> test.txt 
abc  : 123 
3    : 32  
-2.3 

<span class="gp">$ </span>perl -F<span class="s1">'\s*:\s*'</span> -lane <span class="s1">'print join ",", grep {/[a-z]/i} @F'</span> test.txt 
abc,xyz
foo
bar,bar

<span class="gp">$ </span>perl -F: -ane <span class="s1">'print if (grep {/\d/} @F) &lt; 2'</span> test.txt 
abc  : 123 : xyz
-2.3 : bar : bar
</code></pre>
</div>

<p><br /></p>

<ul>
  <li>Dealing with duplicates</li>
</ul>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="gp">$ </span>cat duplicates.txt 
abc 123 ijk
foo 567 xyz
abc 123 ijk
bar 090 pqr
tst 567 zzz

<span class="gp">$ </span><span class="c"># whole line</span>
<span class="gp">$ </span>perl -ne <span class="s1">'print if !$seen{$_}++'</span> duplicates.txt 
abc 123 ijk
foo 567 xyz
bar 090 pqr
tst 567 zzz

<span class="gp">$ </span><span class="c"># particular column</span>
<span class="gp">$ </span>perl -ane <span class="s1">'print if !$seen{$F[1]}++'</span> duplicates.txt 
abc 123 ijk
foo 567 xyz
bar 090 pqr
</code></pre>
</div>

<p><br /></p>

<ul>
  <li>Multiline processing</li>
</ul>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="gp">$ </span><span class="c"># save previous lines to make it easier for multiline matching</span>
<span class="gp">$ </span>perl -ne <span class="s1">'print if /3/ &amp;&amp; $p =~ /abc/; $p = $_'</span> test.txt 
3    : 32  : foo

<span class="gp">$ </span>perl -ne <span class="s1">'print "$p$_" if /3/ &amp;&amp; $p =~ /abc/; $p = $_'</span> test.txt 
abc  : 123 : xyz
3    : 32  : foo

<span class="gp">$ </span><span class="c"># with multiline matching, -0777 slurping not advisable for very large files</span>
<span class="gp">$ </span>perl -0777 -ne <span class="s1">'print $1 if /.*abc.*\n(.*3.*\n)/'</span> test.txt 
3    : 32  : foo
<span class="gp">$ </span>perl -0777 -ne <span class="s1">'print $1 if /(.*abc.*\n.*3.*\n)/'</span> test.txt 
abc  : 123 : xyz
3    : 32  : foo

<span class="gp">$ </span><span class="c"># use s flag to allow .* to match across lines</span>
<span class="gp">$ </span>perl -0777 -pe <span class="s1">'s/(.*abc.*32)/ABC/s'</span> test.txt 
ABC  : foo
-2.3 : bar : bar

<span class="gp">$ </span><span class="c"># use m flag if ^$ anchors are needed to match individual lines</span>
<span class="gp">$ </span>perl -0777 -pe <span class="s1">'s/(.*abc.*3)/ABC/s'</span> test.txt 
ABC : bar : bar
<span class="gp">$ </span>perl -0777 -pe <span class="s1">'s/(.*abc.*^3)/ABC/sm'</span> test.txt 
ABC    : 32  : foo
-2.3 : bar : bar

<span class="gp">$ </span><span class="c"># print multiple lines after matching line</span>
<span class="gp">$ </span>perl -ne <span class="s1">'if(/abc/){ print; foreach (1..2){$n = &lt;&gt;; print $n} }'</span> test.txt 
abc  : 123 : xyz
3    : 32  : foo
-2.3 : bar : bar
</code></pre>
</div>

<p><br /></p>

<ul>
  <li>Using modules</li>
</ul>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="gp">$ </span><span class="nb">echo</span> <span class="s1">'a,b,a,c,d,1,d,c,2,3,1,b'</span> | perl -MList::MoreUtils<span class="o">=</span>uniq -F, -lane <span class="s1">'print join ",",uniq(@F)'</span>
a,b,c,d,1,2,3

<span class="gp">$ </span>base64 test.txt 
YWJjICA6IDEyMyA6IHh5egozICAgIDogMzIgIDogZm9vCi0yLjMgOiBiYXIgOiBiYXIK
<span class="gp">$ </span>base64 test.txt | base64 -d
abc  : 123 : xyz
3    : 32  : foo
-2.3 : bar : bar
<span class="gp">$ </span>base64 test.txt | perl -MMIME::Base64 -ne <span class="s1">'print decode_base64($_)'</span> 
abc  : 123 : xyz
3    : 32  : foo
-2.3 : bar : bar

<span class="gp">$ </span>perl -MList::MoreUtils<span class="o">=</span>indexes -nale <span class="s1">'@i = indexes { /[a-z]/i } @F if $. == 1; print join ",", @F[@i]'</span> test.txt 
abc,xyz
3,foo
-2.3,bar
</code></pre>
</div>

<p><br /></p>

<ul>
  <li>In place editing</li>
</ul>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="gp">$ </span>perl -i -pe <span class="s1">'s/\d/*/g'</span> test.txt 
<span class="gp">$ </span>cat test.txt 
abc  : <span class="k">***</span> : xyz
<span class="k">*</span>    : <span class="k">**</span>  : foo
-<span class="k">*</span>.<span class="k">*</span> : bar : bar

<span class="gp">$ </span>perl -i.bak -pe <span class="s1">'s/\*/^/g'</span> test.txt 
<span class="gp">$ </span>cat test.txt 
abc  : ^^^ : xyz
^    : ^^  : foo
-^.^ : bar : bar
<span class="gp">$ </span>cat test.txt.bak 
abc  : <span class="k">***</span> : xyz
<span class="k">*</span>    : <span class="k">**</span>  : foo
-<span class="k">*</span>.<span class="k">*</span> : bar : bar
</code></pre>
</div>

<p><br /></p>

<p><strong>Further Reading</strong></p>

<ul>
  <li><a href="https://github.com/learnbyexample/Perl_intro">Perl Introduction</a> - Introductory course for Perl 5 through examples</li>
  <li><a href="https://github.com/learnbyexample/scripting_course/blob/master/Perl_curated_resources.md">Perl curated resources</a></li>
  <li><a href="http://www.catonmat.net/blog/perl-one-liners-explained-part-seven/">Handy Perl regular expressions</a></li>
  <li><a href="http://stackoverflow.com/questions/22937618/reference-what-does-this-regex-mean">What does this regex mean?</a></li>
  <li><a href="http://www.catonmat.net/series/perl-one-liners-explained">Perl one-liners</a></li>
  <li><a href="http://perl101.org/command-line-switches.html">Perl command line switches</a></li>
  <li><a href="http://perldoc.perl.org/Env.html">Env</a></li>
</ul>

<p><br /></p>

<h3 id="cut"><a name="cut"></a>cut</h3>

<blockquote>
  <p>remove sections from each line of files</p>
</blockquote>

<p>For columns operations with well defined delimiters, <code class="highlighter-rouge">cut</code> command is handy</p>

<p><strong>Examples</strong></p>

<ul>
  <li><code class="highlighter-rouge">ls -l | cut -d' ' -f1</code> first column of <code class="highlighter-rouge">ls -l</code>
    <ul>
      <li><code class="highlighter-rouge">-d</code> option specifies delimiter character, in this case it is single space character (Default delimiter is TAB character)</li>
      <li><code class="highlighter-rouge">-f</code> option specifies which fields to print separated by commas, in this case field 1</li>
    </ul>
  </li>
  <li><code class="highlighter-rouge">cut -d':' -f1 /etc/passwd</code> prints first column of /etc/passwd file</li>
  <li><code class="highlighter-rouge">cut -d':' -f1,7 /etc/passwd</code> prints 1st and 7th column of /etc/passwd file with : character in between</li>
  <li><code class="highlighter-rouge">cut -d':' --output-delimiter=' ' -f1,7 /etc/passwd</code> use space as delimiter between 1st and 7th column while printing</li>
  <li><a href="https://unix.stackexchange.com/questions/tagged/cut?sort=votes&amp;pageSize=15">cut Q&amp;A on unix stackexchange</a></li>
</ul>

<p><br /></p>

<h3 id="paste"><a name="paste"></a>paste</h3>

<blockquote>
  <p>merge lines of files</p>
</blockquote>

<p><strong>Examples</strong></p>

<ul>
  <li><code class="highlighter-rouge">paste list1.txt list2.txt list3.txt &gt; combined_list.txt</code> combines the three files column-wise into single file, the entries separated by TAB character</li>
  <li><code class="highlighter-rouge">paste -d':' list1.txt list2.txt list3.txt &gt; combined_list.txt</code> the entries are separated by : character instead of TAB
    <ul>
      <li>See <a href="#pr">pr</a> command for multiple character delimiter</li>
    </ul>
  </li>
  <li><a href="https://unix.stackexchange.com/questions/tagged/paste?sort=votes&amp;pageSize=15">paste Q&amp;A on unix stackexchange</a></li>
</ul>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="gp">$ </span><span class="c"># joining multiple files</span>
<span class="gp">$ </span>paste -d, &lt;<span class="o">(</span>seq 5<span class="o">)</span> &lt;<span class="o">(</span>seq 6 10<span class="o">)</span>
1,6
2,7
3,8
4,9
5,10

<span class="gp">$ </span>paste -d, &lt;<span class="o">(</span>seq 3<span class="o">)</span> &lt;<span class="o">(</span>seq 4 6<span class="o">)</span> &lt;<span class="o">(</span>seq 7 10<span class="o">)</span>
1,4,7
2,5,8
3,6,9
,,10
</code></pre>
</div>

<ul>
  <li>Single column to multiple columns</li>
</ul>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="gp">$ </span>seq 5 | paste - -
1	2
3	4
5	

<span class="gp">$ </span><span class="c"># specifying different output delimiter, default is tab</span>
<span class="gp">$ </span>seq 5 | paste -d, - -
1,2
3,4
5,

<span class="gp">$ </span><span class="c"># if number of columns to specify is large, use the printf trick</span>
<span class="gp">$ </span>seq 5 | paste <span class="k">$(</span><span class="nb">printf</span> -- <span class="s2">"- %.s"</span> <span class="o">{</span>1..3<span class="o">}</span><span class="k">)</span>
1	2	3
4	5	
</code></pre>
</div>

<ul>
  <li>Combine all lines to single line</li>
</ul>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="gp">$ </span>seq 10 | paste -sd,
1,2,3,4,5,6,7,8,9,10

<span class="gp">$ </span><span class="c"># for multiple character delimiter, perl can be used</span>
<span class="gp">$ </span>seq 10 | perl -pe <span class="s1">'s/\n/ : / if(!eof)'</span>
1 : 2 : 3 : 4 : 5 : 6 : 7 : 8 : 9 : 10
</code></pre>
</div>

<p><br /></p>

<h3 id="column"><a name="column"></a>column</h3>

<blockquote>
  <p>columnate lists</p>
</blockquote>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="gp">$ </span>cat dishes.txt 
North alootikki baati khichdi makkiroti poha 
South appam bisibelebath dosa koottu sevai 
West dhokla khakhra modak shiro vadapav 
East handoguri litti momo rosgulla shondesh 

<span class="gp">$ </span>column -t dishes.txt 
North  alootikki  baati         khichdi  makkiroti  poha
South  appam      bisibelebath  dosa     koottu     sevai
West   dhokla     khakhra       modak    shiro      vadapav
East   handoguri  litti         momo     rosgulla   shondesh
</code></pre>
</div>

<ul>
  <li>More examples <a href="http://www.commandlinefu.com/commands/using/column/sort-by-votes">here</a></li>
</ul>

<p><br /></p>

<h3 id="pr"><a name="pr"></a>pr</h3>

<blockquote>
  <p>convert text files for printing</p>
</blockquote>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="gp">$ </span>pr sample.txt 


2016-05-29 11:00                    sample.txt                    Page 1


This is an example of adding text to a new file using cat command.
Press Ctrl+d on a newline to save and quit.
Adding a line of text at end of file
</code></pre>
</div>

<ul>
  <li>Options include converting text files for printing with header, footer, page numbers, double space a file, combine multiple files column wise, etc</li>
  <li>More examples <a href="http://docstore.mik.ua/orelly/unix3/upt/ch21_15.htm">here</a></li>
</ul>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="gp">$ </span><span class="c"># single column to multiple column, split vertically</span>
<span class="gp">$ </span><span class="c"># for example, in command below, output of seq is split into two</span>
<span class="gp">$ </span>seq 5 | pr -2t
1				    4
2				    5
3

<span class="gp">$ </span><span class="c"># different output delimiter can be used by passing string to -s option</span>
<span class="gp">$ </span>seq 5 | pr -2ts<span class="s1">' '</span>
1 4
2 5
3

<span class="gp">$ </span>seq 15 | pr -5ts,
1,4,7,10,13
2,5,8,11,14
3,6,9,12,15
</code></pre>
</div>

<ul>
  <li>Use <code class="highlighter-rouge">-a</code> option to split across</li>
</ul>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="gp">$ </span>seq 5 | pr -2ats<span class="s1">' : '</span>
1 : 2
3 : 4
5

<span class="gp">$ </span>seq 15 | pr -5ats,
1,2,3,4,5
6,7,8,9,10
11,12,13,14,15

<span class="gp">$ </span><span class="c"># use $ to expand characters denoted by escape characters like \t for tab</span>
<span class="gp">$ </span>seq 5 | pr -3ts<span class="nv">$'</span><span class="se">\t</span><span class="s1">'
1	3	5
2	4

$ # or leave the argument to -s empty as tab is default
$ seq 5 | pr -3ts
1	3	5
2	4
</span></code></pre>
</div>

<ul>
  <li>The default PAGE_WIDTH is 72</li>
  <li>The formula <code class="highlighter-rouge">(col-1)*len(delimiter) + col</code> seems to work in determining minimum PAGE_WIDTH required for multiple column output</li>
  <li>The <code class="highlighter-rouge">-J</code> option will help in turning off line truncation</li>
</ul>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="gp">$ </span>seq 74 | pr -36ats,
1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36
37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72
73,74
<span class="gp">$ </span>seq 74 | pr -37ats,
pr: page width too narrow

<span class="gp">$ </span><span class="c"># (37-1)*1 + 37 = 73</span>
<span class="gp">$ </span>seq 74 | pr -Jw 73 -37ats,
1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37
38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74

<span class="gp">$ </span><span class="c"># (3-1)*4 + 3 = 11</span>
<span class="gp">$ </span>seq 6 | pr -Jw 10 -3ats<span class="s1">'::::'</span>
pr: page width too narrow
<span class="gp">$ </span>seq 6 | pr -Jw 11 -3ats<span class="s1">'::::'</span>
1::::2::::3
4::::5::::6
</code></pre>
</div>

<ul>
  <li>Use <code class="highlighter-rouge">-m</code> option to combine multiple files in parallel</li>
</ul>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="gp">$ </span>pr -mts<span class="s1">', '</span> &lt;<span class="o">(</span>seq 3<span class="o">)</span> &lt;<span class="o">(</span>seq 4 6<span class="o">)</span> &lt;<span class="o">(</span>seq 7 9<span class="o">)</span>
1, 4, 7
2, 5, 8
3, 6, 9
</code></pre>
</div>

<p><br /></p>

<p>We can use a combination of different commands for complicated operations. For example, transposing a table</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="gp">$ </span>tr <span class="s1">' '</span> <span class="s1">'\n'</span> &lt; dishes.txt | pr -<span class="k">$(</span>wc -l &lt; dishes.txt<span class="k">)</span>t
North               South               West                East
alootikki           appam               dhokla              handoguri
baati               bisibelebath        khakhra             litti
khichdi             dosa                modak               momo
makkiroti           koottu              shiro               rosgulla
poha                sevai               vadapav             shondesh
</code></pre>
</div>

<p>Notice how <code class="highlighter-rouge">pr</code> neatly arranges the columns. If spacing is too much, we can use <code class="highlighter-rouge">column</code></p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="gp">$ </span>tr <span class="s1">' '</span> <span class="s1">'\n'</span> &lt; dishes.txt | pr -<span class="k">$(</span>wc -l &lt; dishes.txt<span class="k">)</span>ts | column -t
North      South         West     East
alootikki  appam         dhokla   handoguri
baati      bisibelebath  khakhra  litti
khichdi    dosa          modak    momo
makkiroti  koottu        shiro    rosgulla
poha       sevai         vadapav  shondesh
</code></pre>
</div>

		
	</div>
</article>



	  </main>
		
		  <!-- Pagination links -->
      

	  </div>
	    
	    <!-- Footer -->
	    <footer><span>@2017 -  <a href="http://0.0.0.0:4000/">IkhwanElyas</a> | <a href="https://github.com/abuisa/abuisa.github.io" target="_blank">github</a> </span> | <a href="https://abuisa.github.io/qweb/" target="_blank">AyatPilihan</a>
</footer>


<!-- original script :
| <a href="https://ikhwanelyas.blogspot.co.id/" target="_blank">Blog</a>
<footer><span>@2017 -  <a href="//">IkhwanElyas</a> | <a href="https://github.com/abuisa/abuisa.github.io" target="_blank">github</a> </span> | <a href="https://ikhwanelyas.blogspot.co.id/" target="_blank">Blog</a>
</footer>
-->


	    <!-- Script -->
      <script src="/js/main.js"></script>	


	</div>
</body>
</html>
